//
// Created by wujiahao on 18-6-19.
//

#ifndef MHHSS_XINANJIANGMODEL_H
#define MHHSS_XINANJIANGMODEL_H

#include <cmath>
#include <list>
#include "base_model.h"

/**
%% 三水源新安江模型
%
% 三水源——地表径流、壤中流、地下径流新安江模型计算流量过程
%
% 输入
%       rainfall，降水量文件路径
%           每行一条记录：时间，降水量(mm)
%       epan，蒸发皿蒸发量文件路径
%           每行一条记录：时间，蒸发皿蒸发量(mm)
%       parameter，基本参数文件路径
%           每行一个参数：
%           计算时间步长（hour）
%           计算总时长（hour）
%           流域面积F（km2）
%           上层流域蓄水容量WUM（mm）
%           下层流域蓄水容量WLM（mm）
%           深层流域蓄水容量WDM（mm）
%			蒸发皿系数K
%			深层蒸散发系数C
%			蓄水容量曲线指数B
%			不透水面积比重IMP
%			自由水蓄水库容量SM（mm）
%			自由水蓄水容量曲线指数EX
%			地下水从自由水库的出流系数KG
%			壤中流出流系数KSS
%			地下水退水系数KKG
%			壤中流退水系数KKSS
%           计算时段DT
%			无因次单位线时段UH
%			上层流域蓄水量WU（mm）
%			下层流域蓄水量WL（mm）
%			深层流域蓄水量WD（mm）
%			产流面积比重FR
%			自由水蓄水量S（mm）
%			壤中流初始流量QRSS0（m3/s）
%			地下水初始流量QRG0（m3/s）
%
% 输出
%       QR，总径流，m3/s
%       QRS，地表径流，m3/s
%       QRSS，壤中流，m3/s
%       QRG，地下径流，m3/s
 */

class XinAnJiangModel : public BaseModel {

public:
    //基本参数
    static const std::string P_F_NAME = "F";          // 流域面积（km2）
    static const std::string P_WUM_NAME = "WUM";      // 上下深层流域蓄水容量（mm）
    static const std::string P_WLM_NAME = "WLM";
    static const std::string P_WDM_NAME = "WDM";
    static const std::string P_K_NAME = "K";          // 蒸发皿系数
    static const std::string P_C_NAME = "C";          // 深层蒸散发系数
    static const std::string P_B_NAME = "B";          // 蓄水容量曲线指数
    static const std::string P_IMP_NAME = "IMP";      // 不透水面积比重
    static const std::string P_SM_NAME = "SM";        // 自由水蓄水库容量（mm）
    static const std::string P_EX_NAME = "EX";        // 自由水蓄水容量曲线指数
    static const std::string P_KG_NAME = "KG";        // 地下水从自由水库的出流系数
    static const std::string P_KSS_NAME = "KSS";      // 壤中流出流系数KSS
    static const std::string P_KKG_NAME = "KKG";      // 地下水退水系数KKG
    static const std::string P_KKSS_NAME = "KKSS";    // 壤中流退水系数KKSS
    static const std::string P_DT_NAME = "DT";        // 计算时段DT
//    static const std::string P_UH1_NAME = "UH1";      // 无因次单位线时段
//    static const std::string P_UH2_NAME = "UH2";
//    static const std::string P_UH3_NAME = "UH3";
    static const std::string P_KSTOR_NAME = "KSTOR";  // day脉冲汇流计算的参数,Liang
//    double m_Kstor;

    //初始状态
    static const std::string I_WU_NAME = "WU";        // 上下深层流域蓄水量（mm）
    static const std::string I_WL_NAME = "WL";
    static const std::string I_WD_NAME = "WD";
    static const std::string I_FR_NAME = "FR";        // 产流面积比重
    static const std::string I_S_NAME = "S";          // 自由水蓄水量（mm）
    static const std::string I_QRSS0_NAME = "QRSS0";  // 壤中流初始流量（m3/s）
    static const std::string I_QRG0_NAME = "QRG0";    // 地下水初始流量（m3/s）

    // input data name
    static const std::string ID_P_NAME = "P";
    static const std::string ID_EI_NAME = "EI";

private:

    double F;
    double WUM, WLM, WDM;
    double K;
    double C;
    double B;
    double IMP;
    double SM;
    double EX;
    double KG;
    double KSS;
    double KKG;
    double KKSS;
    int DT;
    int UH[3];

    double WU, WL, WD;      //上下深层流域蓄水量（mm）
    double FR;              //产流面积比重
    double S;               //自由水蓄水量（mm）
    double QRSS0;           //壤中流初始流量（m3/s）
    double QRG0;            //地下水初始流量（m3/s）

    std::list<double> v_RS_tmp;
    double stateNowRS, stateNowRSS, stateNowRG;
    double statePrevQRSS, statePrevQRG;

public:
    XinAnJiangModel(std::map<std::string, double> &paraDatas, std::map<std::string, double> &initDatas) : BaseModel() {
        this->paraDataNames.push_back(P_F_NAME);
        this->paraDataNames.push_back(P_WUM_NAME);
        this->paraDataNames.push_back(P_WLM_NAME);
        this->paraDataNames.push_back(P_WDM_NAME);
        this->paraDataNames.push_back(P_K_NAME);
        this->paraDataNames.push_back(P_C_NAME);
        this->paraDataNames.push_back(P_B_NAME);
        this->paraDataNames.push_back(P_IMP_NAME);
        this->paraDataNames.push_back(P_SM_NAME);
        this->paraDataNames.push_back(P_EX_NAME);
        this->paraDataNames.push_back(P_KG_NAME);
        this->paraDataNames.push_back(P_KSS_NAME);
        this->paraDataNames.push_back(P_KKG_NAME);
        this->paraDataNames.push_back(P_KKSS_NAME);
        this->paraDataNames.push_back(P_DT_NAME);
//        this->paraDataNames.push_back(P_UH1_NAME);
//        this->paraDataNames.push_back(P_UH2_NAME);
//        this->paraDataNames.push_back(P_UH3_NAME);
        this->paraDataNames.push_back(P_KSTOR_NAME);
        if (!checkParaDatas(paraDatas)) {
            // todo
        }
        this->paraDatas.insert(paraDatas);

        // init initDatas
        this->inputDataNames.push_back(I_WU_NAME);
        this->inputDataNames.push_back(I_WL_NAME);
        this->inputDataNames.push_back(I_WD_NAME);
        this->inputDataNames.push_back(I_FR_NAME);
        this->inputDataNames.push_back(I_S_NAME);
        this->inputDataNames.push_back(I_QRSS0_NAME);
        this->inputDataNames.push_back(I_QRG0_NAME);
        if (!checkInitDatas(paraDatas)) {
            // todo
        }
        this->initDatas.insert(initDatas);

        // init inputDatas
        this->inputDataNames.push_back(ID_P_NAME);
        this->inputDataNames.push_back(ID_EI_NAME);
    }

    void runModel(double *P, double *EI, int len) {
        double W = WU + WL + WD;
        double WM = WUM + WLM + WDM;
        double WWMM = (1 + B) * WM;
        double A = WWMM * (1 - pow((1 - W / WM), (1 / (1 + B))));

        double R[len];
        double E[len];

        double RS[len], RSS[len], RG[len];

        for (int i = 0; i < len; ++i) {

            double EM = K * EI[i]; //蒸散发能力
            double PE = P[i] - EM; //%计算净雨量

            //计算进入自由水库的水量R
            if (PE > 0) {
                if (PE + A >= WWMM) {
                    R[i] = PE - (WM - W);
                } else {
                    R[i] = PE - ((WM - W) - WM * pow((1 - (PE + A) / WWMM), (1 + B)));
                }
            } else {
                R[i] = 0;
            }

            //计算蒸发
            double WU1 = WU + P[i]; //随着降雨流域蓄水量从表层发生变化，同时也有蒸发的存在
            double EU, EL, ED;
            if (WU1 >= EM) {
                EU = EM;
                EL = 0;
                ED = 0;
            } else {
                EU = WU1;
                if (C <= WL / WLM) {
                    EL = (EM - EU) * WL / WLM;
                    ED = 0;
                } else if (C <= WL / (EM - EU)) {
                    EL = C * (EM - EU);
                    ED = 0;
                } else {
                    EL = WL;
                    ED = C * (EM - EU) - EL;
                }
            }
            E[i] = EU + EL + ED;


            //利用自由水蓄水容量曲线计算产流量
            double SSM = (1 + EX) * SM; //%域上自由水蓄水量最大的某点的蓄量值
            double AU = SSM * (1 - pow((1 - S / SM), (1 / (1 + EX)))); //与自由水蓄水量S对应的蓄水容量曲线的纵坐标值
            if (PE <= 0) {
                RS[i] = 0;
                RSS[i] = S * KSS * FR; //%FR最初采用初始值
                RG[i] = S * KG * FR;
                S = (1 - KSS - KG) * S;
            } else {
                if (R[i] / PE > 1) { //产流面积比重等效于径流系数
                    FR = 1;
                } else {
                    FR = R[i] / PE;
                }

                if (PE + AU < SSM) {
                    RS[i] = (PE - SM + S + SM * pow((1 - (PE + AU) / SSM), (1 + EX))) * FR;
                    RSS[i] = (SM - SM * pow((1 - (PE + AU) / SSM), (1 + EX))) * KSS * FR;
                    RG[i] = (SM - SM * pow((1 - (PE + AU) / SSM), (1 + EX))) * KG * FR;
                    S = (1 - KSS - KG) * (SM - SM * pow((1 - (PE + AU) / SSM), (1 + EX)));
                } else {
                    RS[i] = (PE - SM + S) * FR;
                    RSS[i] = SM * KSS * FR;
                    RG[i] = SM * KG * FR;
                    S = (1 - KSS - KG) * SM;
                }
            }
            RS[i] = P[i] * IMP + RS[i] * (1 - IMP); //考虑不透水面
            FR = 1 - pow((1 - W / WM), (B / (1 + B)));

            //计算蓄水量的变化
            WU = WU + P[i] - R[i] - EU;
            if (WU >= WUM) {
                WL = WL - EL + (WU - WUM);
                if (WL >= WLM) {
                    WD = WD - ED + (WL - WLM);
                    if (WD >= WDM) {
                        WD = WDM;
                    } else {
                        WD = WD;
                    }
                    WL = WLM;
                } else {
                    WL = WL;
                }
                WU = WUM;
            } else {
                WU = WU;
            }
            W = WU + WL + WD;
        }

        // ------汇流计算------%
        // 地表径流
        double q[3];
        //=10*F*UH./3.6/DT;
        for (int i = 0; i < 3; ++i) {
            q[i] = 10 * F * UH[i] / 3.6 / DT;
        }
        int D = 24 / DT; //一日内时段数
        double QRS[len + 3 - 1] = {0};
        for (int i = 0; i < len; ++i) {
            for (int j = 0; j < 3; ++j) {
                QRS[i + j] = QRS[i + j] + RS[i] / 10 * q[j];
            }
        }

        double QRG[len], QRSS[len];
        QRG[0] = QRG0 * pow(KKG, (1 / D)) + RG[0] * (1 - pow(KKG, (1 / D))) * F / 3.6 / DT;
        QRSS[0] = QRSS0 * pow(KKSS, (1 / D)) + RSS[0] * (1 - pow(KKSS, (1 / D))) * F / 3.6 / DT;

        for (int i = 0; i < len - 1; ++i) {
            QRG[i + 1] = QRG[i] * pow(KKG, (1 / D)) + RG[i] * (1 - pow(KKG, (1 / D))) * F / 3.6 / DT;
            QRSS[i + 1] = QRSS[i] * pow(KKSS, (1 / D)) + RSS[i] * (1 - pow(KKSS, (1 / D))) * F / 3.6 / DT;
        }
    }

protected:
    void produceFlowSimul(std::map<std::string, double> &inputDatas, int nowTimestep) override {
        double W = getInitValue(I_WU_NAME) + getInitValue(I_WL_NAME) + getInitValue(I_WD_NAME); //WU + WL + WD;
        double WM = getParaValue(P_WUM_NAME) + getParaValue(P_WLM_NAME) + getParaValue(P_WDM_NAME); //WUM + WLM + WDM;
        double WWMM = (1 + getParaValue(P_B_NAME)) * WM;
        double A = WWMM * (1 - pow((1 - W / WM), (1 / (1 + getParaValue(P_B_NAME)))));

        double EM = getParaValue(P_K_NAME) * inputDatas.at(ID_EI_NAME); //蒸散发能力
        double PE = inputDatas.at(ID_P_NAME) - EM; //计算净雨量

        //计算进入自由水库的水量R
        double R;
        if (PE > 0) {
            if (PE + A >= WWMM) {
                R = PE - (WM - W);
            } else {
                R = PE - ((WM - W) - WM * pow((1 - (PE + A) / WWMM), (1 + getParaValue(P_B_NAME))));
            }
        } else {
            R = 0;
        }

        //计算蒸发
        double E;
        double WU1 = getInitValue(I_WU_NAME) + inputDatas.at(ID_P_NAME); //随着降雨流域蓄水量从表层发生变化，同时也有蒸发的存在
        double EU, EL, ED;

        if (WU1 >= EM) {
            EU = EM;
            EL = 0;
            ED = 0;
        } else {
            EU = WU1;
            if (getParaValue(P_C_NAME) <= getInitValue(I_WL_NAME) / getParaValue(P_WLM_NAME)) {
                EL = (EM - EU) * getInitValue(I_WL_NAME) / getParaValue(P_WLM_NAME);
                ED = 0;
            } else if (getParaValue(P_C_NAME) <= getInitValue(I_WL_NAME) / (EM - EU)) {
                EL = getParaValue(P_C_NAME) * (EM - EU);
                ED = 0;
            } else {
                EL = getInitValue(I_WL_NAME);
                ED = getParaValue(P_C_NAME) * (EM - EU) - EL;
            }
        }
        E = EU + EL + ED;

        //利用自由水蓄水容量曲线计算产流量
        double RS, RSS, RG;
        double SSM = (1 + getParaValue(P_EX_NAME)) * getParaValue(P_SM_NAME); //域上自由水蓄水量最大的某点的蓄量值
        double AU = SSM * (1 - pow((1 - getInitValue(I_S_NAME) / getParaValue(P_SM_NAME)),
                                   (1 / (1 + getParaValue(P_EX_NAME))))); //与自由水蓄水量S对应的蓄水容量曲线的纵坐标值

        if (PE <= 0) {
            RS = 0;
            RSS = getInitValue(I_S_NAME) * getParaValue(P_KSS_NAME) * getInitValue(I_FR_NAME); //%FR最初采用初始值
            RG = getInitValue(I_S_NAME) * getParaValue(P_KG_NAME) * getInitValue(I_FR_NAME);
            updateInitValue(I_S_NAME,
                            (1 - getParaValue(P_KSS_NAME) - getParaValue(P_KG_NAME)) * getInitValue(I_S_NAME));
        } else {
            if (R / PE > 1) { //产流面积比重等效于径流系数
                updateInitValue(I_FR_NAME, 1);
            } else {
                updateInitValue(I_FR_NAME, R / PE);
            }

            if (PE + AU < SSM) {
                RS = (PE - getParaValue(P_SM_NAME) + getInitValue(I_S_NAME) +
                      getParaValue(P_SM_NAME) * pow((1 - (PE + AU) / SSM), (1 + getParaValue(P_EX_NAME)))) *
                     getInitValue(I_FR_NAME);
                RSS = (getParaValue(P_SM_NAME) -
                       getParaValue(P_SM_NAME) * pow((1 - (PE + AU) / SSM), (1 + getParaValue(P_EX_NAME)))) *
                      getParaValue(P_KSS_NAME) * getInitValue(I_FR_NAME);
                RG = (getParaValue(P_SM_NAME) -
                      getParaValue(P_SM_NAME) * pow((1 - (PE + AU) / SSM), (1 + getParaValue(P_EX_NAME)))) *
                     getParaValue(P_KG_NAME) * getInitValue(I_FR_NAME);
                updateInitValue(I_S_NAME, (1 - getParaValue(P_KSS_NAME) - getParaValue(P_KG_NAME)) *
                                          (getParaValue(P_SM_NAME) - getParaValue(P_SM_NAME) *
                                                                     pow((1 - (PE + AU) / SSM),
                                                                         (1 + getParaValue(P_EX_NAME)))));
            } else {
                RS = (PE - getParaValue(P_SM_NAME) + getInitValue(I_S_NAME)) * getInitValue(I_FR_NAME);
                RSS = getParaValue(P_SM_NAME) * getParaValue(P_KSS_NAME) * getInitValue(I_FR_NAME);
                RG = getParaValue(P_SM_NAME) * getParaValue(P_KG_NAME) * getInitValue(I_FR_NAME);
                updateInitValue(I_S_NAME,
                                (1 - getParaValue(P_KSS_NAME) - getParaValue(P_KG_NAME)) * getParaValue(P_SM_NAME));
            }
        }
        RS = getInitValue(ID_P_NAME) * getParaValue(P_IMP_NAME) + RS * (1 - getParaValue(P_IMP_NAME)); //考虑不透水面
        updateInitValue(I_FR_NAME, 1 - pow((1 - W / WM), (getParaValue(P_B_NAME) / (1 + getParaValue(P_B_NAME)))));

        //计算蓄水量的变化
        updateInitValue(I_WU_NAME, getInitValue(I_WU_NAME) + getInitValue(ID_P_NAME) - R - EU);
        if (getInitValue(I_WU_NAME) >= getParaValue(P_WUM_NAME)) {
            updateInitValue(I_WL_NAME,
                            getInitValue(I_WL_NAME) - EL + (getInitValue(I_WU_NAME) - getParaValue(P_WUM_NAME)));
            if (getInitValue(I_WL_NAME) >= getParaValue(P_WLM_NAME)) {
                updateInitValue(I_WD_NAME,
                                getInitValue(I_WD_NAME) - ED + (getInitValue(I_WL_NAME) - getParaValue(P_WLM_NAME)));
                if (getInitValue(I_WD_NAME) >= getParaValue(P_WDM_NAME)) {
                    updateInitValue(I_WD_NAME, getParaValue(P_WDM_NAME));
                }
                updateInitValue(I_WL_NAME, getParaValue(P_WLM_NAME));
            }
            updateInitValue(I_WU_NAME, getParaValue(P_WUM_NAME));
        }
        W = getInitValue(I_WU_NAME) + getInitValue(I_WL_NAME) + getInitValue(I_WD_NAME);

        stateNowRS = RS;
        stateNowRSS = RSS;
        stateNowRG = RG;
    }

    RoutingDataMeta routeFlowSimul(std::map<std::string, double> &inputDatas, int nowTimestep, std::vector<RoutingDataMeta> upRoutedDatas) override {
        // ------汇流计算------%
        // 地表径流
        double D = 24 / (getParaValue(P_DT_NAME)); ////一日内时段数
        double K = getParaValue(P_KSTOR_NAME) * D;  // todo

        // 单位线推导
        double sum_UH = 0.0;
        std::vector<double> UH;
        int i = 0;
        while (true) {
            double uh = (1.0 / K) * exp((-1.0 * i) / K);
            if (uh >= 1.0) {
                UH.push_back(1.0);
                break;
            }
            if (sum_UH + uh > 1) {
                uh = 1.0 - sum_UH;
                UH.push_back(uh);
                break;
            } else {
                sum_UH = sum_UH + uh;
                UH.push_back(uh);
            }
            i++;
        }
        // 单位线汇流计算
        if (nowTimestep <= UH.size()) {
            v_RS_tmp.push_back(stateNowRS);
        } else {
            v_RS_tmp.push_back(stateNowRS);
            v_RS_tmp.pop_front();
        }
        double QRS = 0;
        i = UH.size();
        for (std::list<double>::iterator it = v_RS_tmp.begin(); it != v_RS_tmp.end(); it++) {
            double q = 10 * getParaValue(P_F_NAME) * UH[i] / 3.6 / getParaValue(P_DT_NAME);
            QRS += *it / 10 * q;
            i--;
        }

        double QRG, QRSS;
        if (nowTimestep == 1) {
            QRG = getInitValue(I_QRG0_NAME) * pow(KKG, (1 / D)) + stateNowRG * (1 - pow(KKG, (1 / D))) * F / 3.6 / DT;
            QRSS = getInitValue(I_QRG0_NAME) * pow(KKSS, (1 / D)) +
                   stateNowRSS * (1 - pow(KKSS, (1 / D))) * F / 3.6 / DT;
        } else {
            QRG = statePrevQRG * pow(KKG, (1 / D)) + stateNowRG * (1 - pow(KKG, (1 / D))) * F / 3.6 / DT;
            QRSS = statePrevQRSS * pow(KKSS, (1 / D)) + stateNowRSS * (1 - pow(KKSS, (1 / D))) * F / 3.6 / DT;
        }
        statePrevQRSS = QRSS;
        statePrevQRG = QRG;
    }

};


#endif //MHHSS_XINANJIANGMODEL_H
